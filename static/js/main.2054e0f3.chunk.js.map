{"version":3,"sources":["models/jellyman.glb","components/Utility.js","components/PatternManager.js","components/Agent.js","components/Liarbird.js","components/OctreeManager.js","components/World.js","components/App.js","index.js"],"names":["module","exports","axisRotation","axis_x","axis_y","axis_z","angle_radians","q","norm","Math","sqrt","cos","sin","set","Pattern","patternObj","this","theta_rad","amp","isClockwise","dir","originPos","pos","moveFactor","move","targetPos","THREE","maxTheta","r","x","z","y","EllipsePattern","radX","radx","radZ","radz","PI","xPos","cartesianX","zPos","cartesianZ","yPos","cartesianY","updateTheta","RosePattern","rad","phase","ph","numPetals","numP","isSin","FLOCKING_WEIGHTS","Agent","scene","i","startY","idx","position","velocity","acceleration","fSteer","sumVec","diffVec","rotationA","rotationB","initialPatternPosition","target","maxForce","maxSpeed","maxSlowDownSpeed","slowDownTolerance","arriveTolerance","smoothFactor","initPosition","setupPattern","clone","d","radius","amplitude","isSinusoidal","roseConstructor","degToRad","rosePattern","nAgents","applyBehaviors","updatePosition","seek","applyForce","flock","length","seperation","cohesion","align","subVectors","value","low1","high1","low2","high2","lengthSq","normalize","newMaxSpeed","multiplyScalar","sub","clampLength","add","addVectors","lerp","forEach","a","divideScalar","loader","GLTFLoader","Liarbird","loadLiarbird","load","model","gltf","jellyman","frustumCulled","agent","castShadow","receiveShadow","agentRotation","rotation","agentScale","scale","agentAnimations","animations","animationMixer","clipAction","play","undefined","error","console","delta","update","updateAgent","syncPosition","syncRotation","copy","azimuth","inclination","v","atan2","acos","Utility","multiply","setRotationFromQuaternion","setTarget","getTargetPos","Octree","origin","boundary","min","Vector3","max","tree","PointOctree","insert","findPoints","pointCount","OctreeManager","flockOctree","flockTarget","liarbirds","setupOctree","l","insertPoint","scanForPoints","n","push","OrbitControls","oc","WORLD_STATE","styles","container","zIndex","top","overflowX","overflowY","World","props","state","ref","React","createRef","camera","window","innerWidth","innerHeight","lookAt","renderer","alpha","octreeManager","curWorldState","controls","stats","Stats","clock","setSize","setPixelRatio","devicePixelRatio","outputEncoding","current","appendChild","domElement","dom","ambientLight","intensity","directionalLight","inc","abs","startPos","enablePan","enabled","enableKeys","ellipseConstructor","flockPattern","initThreeRender","scheduleStates","getDelta","getNeighbours","updateRosePattern","style","begin","render","end","requestAnimationFrame","bind","h","newWidth","log","newHeight","aspect","setViewport","updateProjectionMatrix","setInterval","Component","Radium","App","totalRef","worldRef","setTimeout","scrollHeight","ReactDOM","document","getElementById"],"mappings":"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","file":"static/js/main.2054e0f3.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/jellyman.5ff4e054.glb\";","const getRandomNum = (max = 0, min = 0) => {\n    return Math.floor(Math.random() * (max + 1 - min)) + min;\n}\n\nconst map_range = (value, low1, high1, low2, high2) => {\n    return low2 + (high2 - low2) * (value - low1) / (high1 - low1);\n}\n\nconst azimuth = (v) => {\n    return Math.atan2(v.y, v.x);\n}\n\nconst inclination = (v) => {\n    return Math.acos(v.z / v.length());\n}\n\nconst axisRotation = (axis_x, axis_y, axis_z, angle_radians, q) => {\n    var norm = Math.sqrt(axis_x * axis_x + axis_y * axis_y + axis_z * axis_z);\n    axis_x /= norm;\n    axis_y /= norm;\n    axis_z /= norm;\n    var cos = Math.cos(angle_radians / 2);\n    var sin = Math.sin(angle_radians / 2);\n    q.set(axis_x * sin, axis_y * sin, axis_z * sin, cos); \n}\n\nexport {\n    getRandomNum,\n    map_range,\n    azimuth,\n    inclination,\n    axisRotation\n}","import * as THREE from 'three'\n\nclass Pattern {\n    constructor(patternObj) {\n        this.theta_rad = 0; \n        this.amp = patternObj.amp;  \n        this.isClockwise = patternObj.dir; \n        this.originPos = patternObj.pos; \n        this.moveFactor = patternObj.move; \n        this.targetPos = new THREE.Vector3(0, 0, 0); // Agents follow this target. \n    }\n\n    updateTheta(maxTheta) {\n        // Update theta based on direction. \n        this.theta_rad = this.isClockwise ? \n            this.theta_rad + this.moveFactor : \n            this.theta_rad - this.moveFactor; \n\n        // Reset theta. \n        this.theta_rad = this.theta_rad >= maxTheta ? 0 : this.theta_rad;\n    }\n\n    cartesianX(r) {\n        return this.originPos.x + r * Math.cos(this.theta_rad);\n    }\n\n    cartesianZ(r) {\n        return this.originPos.z + r * Math.sin(this.theta_rad);\n    }\n    \n    cartesianY(r) {\n        return this.originPos.y + this.amp * Math.sin(this.theta_rad);\n    }\n\n    getTargetPos() {\n        return this.targetPos; \n    }\n\n    // Debug Only \n    // To see where we're at. \n    syncPatternObj() {\n        // SparkUtility.syncSceneObject(this.originObj, this.targetPos); \n    }\n}\n\nexport const ellipseConstructor = (originPos, radX, radZ, amplitude, isClockwise, moveFactor) => {\n    return {\n        pos: originPos, // C\n        radx: radX,\n        radz: radZ,\n        amp: amplitude, // C\n        dir: isClockwise, // C\n        move: moveFactor // C\n    }; \n}\n\nexport class EllipsePattern extends Pattern {\n    constructor(patternObj) {\n        super(patternObj); \n        this.radX = patternObj.radx; \n        this.radZ = patternObj.radz; \n        this.maxTheta = 2*Math.PI; \n    }\n\n    update() {\n        // Ellipse: Cartesian coordinates. \n        let xPos = this.cartesianX(this.radX); // Defines polar curve. \n        let zPos = this.cartesianZ(this.radZ); // Define polar curve. \n        let yPos = this.cartesianY(); // Defines height. \n        this.targetPos.set(xPos, yPos, zPos); \n\n        this.updateTheta(this.maxTheta); \n    }\n}\n\nexport const roseConstructor = (originPos, radius, phase, numPetals, amplitude, isSinusoidal, isClockwise, moveFactor) => {\n    return {\n        pos: originPos, // C\n        rad: radius,\n        ph: phase, \n        numP: numPetals,\n        amp: amplitude, // C\n        isSin: isSinusoidal,\n        dir: isClockwise, // C\n        move: moveFactor // C\n    }\n}\n\n// r = asin(b + cTheta); \n// r = acos(b + cTheta); \n// a = radius\n// b = phase\n// c = numPetals\nexport class RosePattern extends Pattern {\n    constructor(patternObj) {\n        super(patternObj); \n        this.rad = patternObj.rad; \n        this.phase = patternObj.ph; \n        this.numPetals = patternObj.numP;\n        this.isSin = patternObj.isSin; \n        this.maxTheta = Math.PI; \n    }\n\n    update() {\n        let xPos, yPos, zPos; \n        let r = this.isSin ? this.rad * Math.sin(this.phase + this.numPetals * this.theta_rad) : \n            this.rad * Math.cos(this.phase + this.numPetals * this.theta_rad)\n\n        xPos = this.cartesianX(r); // Defines polar curve. \n        zPos = this.cartesianZ(r); // Defines polar curve. \n        yPos = this.cartesianY(); // Defines height. \n\n        this.targetPos.set(xPos, yPos, zPos); \n\n        this.updateTheta(this.maxTheta);\n    }\n}","import * as THREE from 'three'\n// import Target from './Target'\nimport * as Utility from './Utility'\nimport { RosePattern, roseConstructor} from './PatternManager'\n\nconst FLOCKING_WEIGHTS = {\n    SEPERATION: 5.0,\n    COHESION: 1.5,\n    ALIGNMENT: 1.5\n}\n\nexport default class Agent {\n    constructor(scene, i, startY, phase) {\n        this.idx = i; \n        // Construct all important variables. \n        this.position = new THREE.Vector3(0, 0, 0); // Get initial velocity\n        this.velocity = new THREE.Vector3(0.1, 0.3, 0); \n        this.acceleration = new THREE.Vector3(0, 0, 0); \n        this.fSteer = new THREE.Vector3(0, 0, 0); \n        this.sumVec = new THREE.Vector3(0, 0, 0);\n        this.diffVec = new THREE.Vector3(0, 0, 0); \n        this.rotationA = new THREE.Quaternion(); \n        this.rotationB = new THREE.Quaternion(); \n\n        this.initialPatternPosition = new THREE.Vector3(0, startY, 0); \n\n        this.target = new THREE.Vector3(0, 0, 0); \n  \n        // Force and speeds. \n        this.maxForce = 1.5; \n        this.maxSpeed = 1.5; \n        this.maxSlowDownSpeed = 0; \n\n        // Tolerances\n        this.slowDownTolerance = 0.2 * 0.2; \n        this.arriveTolerance = 0.01 * 0.01; \n\n        // Velocity smooth\n        this.smoothFactor = 0.001; \n\n        // Initial position and target.\n        this.initPosition(startY); \n\n        // Create a polar pattern. \n        this.setupPattern(phase);\n    }\n\n    initPosition(startY) {\n        this.position.x = -50;\n        this.position.z = 100; \n        this.position.y = startY;\n    }\n\n    setupPattern(phase) {\n        // Setup pattern variables. \n        let pos = this.initialPatternPosition.clone(); // Target position\n        let d = this.idx % 2 === 0 ? true : false; // Direction\n        let isSin = d; \n        let rad = 50; // Radius\n        let moveFactor = THREE.Math.degToRad(0.1); // How fast to move\n        let petals = 5; \n        let amp = 20; \n        let patternObj = roseConstructor(pos, rad, phase, petals, amp, isSin, d, moveFactor); \n        this.rosePattern = new RosePattern(patternObj); \n    }\n\n    updateAgent(nAgents) {\n        // Behaviors. \n        this.applyBehaviors(nAgents);\n        this.updatePosition();\n    }\n\n    applyBehaviors(nAgents) {\n        this.seek();\n        this.applyForce(); \n\n        this.flock(nAgents); \n    }\n\n    flock(nAgents) {\n        if (nAgents.length > 0) {\n            // Seperation\n            this.seperation(nAgents);\n            this.applyForce();\n\n            // Cohesion\n            this.cohesion(nAgents);\n            this.applyForce();\n\n            // Alignment\n            this.align(nAgents); \n            this.applyForce(); \n        }\n    }\n\n    seek() {\n        this.fSteer.subVectors(this.target, this.position); \n        let d = this.fSteer.lengthSq();\n        this.fSteer.normalize();\n\n        if (d < this.slowDownTolerance && d > this.arriveTolerance) {\n            // Start slowing down. \n            let newMaxSpeed = Utility.map_range(d, this.slowDownTolerance, this.arriveTolerance, this.maxSpeed, this.maxSlowDownSpeed); \n            this.fSteer.multiplyScalar(newMaxSpeed); \n        } else {\n            // We are still trying to get to the target. \n            this.fSteer.multiplyScalar(this.maxSpeed); \n        }\n\n        this.fSteer.sub(this.velocity); \n        //this.fSteer = MathUtility.clamp(this.fSteer, this.maxForce); \n        this.fSteer.clampLength(-99999, this.maxForce); \n    }\n\n    applyForce() {\n        this.acceleration.add(this.fSteer); \n    }\n\n    updatePosition() {\n        // // What's my target velocity? \n        this.sumVec.addVectors(this.velocity, this.acceleration); \n        \n        // What's my intermediate velocity? \n        // Lerp the velocity rather than just updating straight up.\n        this.velocity = this.velocity.lerp(this.sumVec, this.smoothFactor); \n        //this.velocity = MathUtility.clamp(this.velocity, this.maxSpeed); \n        this.velocity.clampLength(-9999, this.maxSpeed); \n\n        this.position.add(this.velocity); \n\n        // Reset acceleration. \n        this.acceleration.multiplyScalar(0);\n    }\n\n    // Receives neighboring agents using Octree calculations. \n    seperation(nAgents) {\n        this.fSteer.set(0, 0, 0); \n        this.sumVec.set(0, 0, 0); \n\n        if (nAgents.length > 0) {\n            nAgents.forEach(a => {\n                this.diffVec.subVectors(this.position, a.position); \n                this.diffVec.normalize(); \n                this.diffVec.divideScalar(this.diffVec.length());  // Weight the vector properly based on the distance from the target. \n                this.sumVec.add(this.diffVec); \n            });\n            \n            // Calculate desired force using the average desired velocity \n            this.sumVec.divideScalar(nAgents.length); \n            if (this.sumVec.lengthSq() > 0) {\n                this.sumVec.normalize(); \n                this.sumVec.clampLength(-99999, this.maxSpeed);\n                this.fSteer.subVectors(this.sumVec, this.velocity);\n                this.fSteer.clampLength(-99999, this.maxForce); \n                this.fSteer.multiplyScalar(FLOCKING_WEIGHTS.SEPERATION); // Apply seperation weight. \n            }\n        }\n    }\n    \n    // Receives neighboring agents using Octree calculations. \n    cohesion(nAgents) {\n        this.target.set(0, 0, 0); \n        this.fSteer.set(0, 0, 0); \n\n        if (nAgents.length > 0) {\n            nAgents.forEach(a => {\n                this.target.add(a.position); \n            }); \n\n            this.target.divideScalar(nAgents.length); \n            this.seek(); // Seek the new target\n            this.fSteer.multiplyScalar(FLOCKING_WEIGHTS.COHESION); \n        }\n    }\n    \n    // Receives neighboring agents using Octree calculations. \n    align(nAgents) {\n        this.fSteer.set(0, 0, 0); \n\n        if (nAgents.length > 0) {\n            nAgents.forEach(a => {\n                this.fSteer.add(a.velocity); \n            }); \n        \n            this.fSteer.divideScalar(nAgents.length); \n            this.fSteer.normalize(); \n            this.fSteer.multiplyScalar(this.maxSpeed); \n            this.fSteer.sub(this.velocity); \n            this.fSteer.clampLength(-99999, this.maxForce); \n            this.fSteer.multiplyScalar(FLOCKING_WEIGHTS.ALIGNMENT); // Apply alignment weight. \n        }\n    }\n}","import * as THREE from 'three'\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'\nimport Agent from './Agent.js'\nimport model from '../models/jellyman.glb'; \nimport * as Utility from './Utility';\n\nconst loader = new GLTFLoader(); \n\nexport default class Liarbird extends Agent {\n    constructor(scene, idx, startY, phase) {\n        super(scene, idx, startY, phase);\n        this.loadLiarbird(scene); \n    }\n\n    loadLiarbird(scene) {\n        loader.load(model, gltf=> {\n            // Set important gltf properties.  \n            this.jellyman = gltf.scene; \n            // Move the pivot close to its neck. \n            this.jellyman.position.set(0, -1.5, 0);\n            this.jellyman.frustumCulled = false;\n\n            // Agent is the parent object. \n            this.agent = new THREE.Group();\n            this.agent.add(this.jellyman); \n            this.agent.frustumCulled = false;\n            this.agent.castShadow = true;\n            this.agent.receiveShadow = true; \n\n            this.agentRotation = this.agent.rotation; \n            this.agentScale = this.agent.scale; \n            this.agentAnimations = gltf.animations; \n\n            // Scale\n            this.agentScale.set(25, 25, 25);\n\n            // Animation. \n            this.animationMixer = new THREE.AnimationMixer(this.agent); \n            var action = this.animationMixer.clipAction(this.agentAnimations[0]);\n            action.play(); \n\n            // Add it to the scene. \n            scene.add(this.agent); \n        }, undefined, function ( error ) {\n            console.error( error );\n        }); \n    }\n\n    update(delta, nAgents) {\n        // Animation update. \n        if (this.animationMixer) {\n            this.animationMixer.update(delta);\n\n            // Behaviors. \n            this.updateAgent(nAgents); \n\n            // Sync rotation and position. \n            this.syncPosition();\n            this.syncRotation(); \n        }\n    }\n\n    syncPosition() {\n        // Sync position of the agent with \n        // the actual agent scene. \n        this.agent.position.copy(this.position);\n    }\n\n    syncRotation() {\n        // Agent rotation\n        let azimuth, inclination; \n        azimuth = Utility.azimuth(this.velocity); \n        inclination = Utility.inclination(this.velocity);\n\n        Utility.axisRotation(0, 0, 1, azimuth - Math.PI/2, this.rotationA); \n        Utility.axisRotation(1, 0, 0, Math.PI/2 - inclination, this.rotationB); \n                    \n        this.rotationA.multiply(this.rotationB);\n        this.agent.setRotationFromQuaternion(this.rotationA);\n\n        // Jellyman rotation\n        this.jellyman.rotation.y += 0.05;\n    }\n\n    updateRosePattern() {\n         // Pattern updates.\n         this.rosePattern.update();\n         this.setTarget(this.rosePattern.getTargetPos()); \n    }\n\n    setTarget(target) {\n        this.target.copy(target);\n    }\n}\n\n\n","\nimport { Vector3 } from 'math-ds';\nimport { PointOctree } from 'sparse-octree'; \n\nconst BIAS = 0.0; // No loose octree. \nconst MAX_POINTS = 2.0; // Maximum points before the tree splits. \nexport class Octree {\n    constructor(origin, boundary) {\n        let min = new Vector3(0, 0, 0);\n        let max = new Vector3(0, 0, 0);\n\n        min.x = origin.x - boundary; \n        min.y = origin.y - boundary; \n        min.z = origin.z - boundary; \n\n        max.x = origin.x + boundary; \n        max.y = origin.y + boundary; \n        max.z = origin.z + boundary;\n\n        this.tree = new PointOctree(min, max, BIAS, MAX_POINTS); \n    }\n\n    // Insert a point into the octree along with the data that should be retried. \n    insertPoint(position, agent) {\n        this.tree.insert(position, agent); \n    }\n\n    // Finds all the points in the octree within a given radius. \n    scanForPoints(position, radius) {\n        return this.tree.findPoints(position, radius, true); \n    }\n\n    pointCount() {\n        return this.tree.pointCount; \n    } \n}\n\nconst OCTREE_HOOD_BOUNDARY = 75; \nconst NEIGHBOUR_RADIUS = 40; // Radius from the origin.\nexport class OctreeManager {\n    constructor() {\n        this.flockOctree = {};\n    }\n\n    update(flockTarget, liarbirds) {\n        this.setupOctree(flockTarget, liarbirds); \n    }\n\n    setupOctree(flockTarget, liarbirds) {\n        this.flockOctree = new Octree(flockTarget, OCTREE_HOOD_BOUNDARY); \n        liarbirds.forEach(l => {\n            this.flockOctree.insertPoint(l.position, l); \n        }); \n    }\n\n    // Neighbours around a point. \n    getNeighbours(origin) {\n        let neighbours; let nAgents=[]; \n        neighbours = this.flockOctree.scanForPoints(origin, NEIGHBOUR_RADIUS);\n        neighbours.forEach(n => {\n            let a = n['data']; \n            nAgents.push(a); \n        }); \n        return nAgents; \n    }\n}\n\n          ","import React from 'react'\nimport Radium from 'radium'\nimport * as THREE from 'three'\nimport oc from 'three-orbit-controls'\nimport Liarbird from './Liarbird.js'\nimport Stats from 'stats.js'\nimport { OctreeManager } from './OctreeManager.js'\nimport { EllipsePattern, ellipseConstructor } from './PatternManager.js'\n\nconst OrbitControls = oc(THREE); \nexport const WORLD_STATE = {\n  PATTERN: 0,\n  FLOCK: 1\n}; \n\nconst styles = {\n    container: {\n        // position: 'absolute',\n        zIndex: 0,\n        top: '0%',\n        overflowX: 'hidden',\n        overflowY: 'auto'\n    }\n};\n\nclass World extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state={\n\n    };\n\n    this.ref = React.createRef(); \n    \n    this.scene = new THREE.Scene(); \n    // (FOV, AspectRatio, Near Clipping, Far Clipping)\n    this.camera = new THREE.PerspectiveCamera(100, window.innerWidth/window.innerHeight, 0.05, 20000);\n    this.camera.position.set(0, 150, 100); \n    this.camera.lookAt(new THREE.Vector3(0, 0, 0));\n    this.camera.frustumCulled = false; \n\n    // Renders the scene as a canvas element. \n    this.renderer = new THREE.WebGLRenderer({\n      alpha: true\n    }); \n\n    // All the agents. \n    this.liarbirds = [];\n\n    // Octree manager for flocking. \n    this.octreeManager = new OctreeManager(); \n\n    // Starting state is patterns. \n    this.curWorldState = WORLD_STATE.PATTERN;\n\n    this.controls = new OrbitControls(this.camera); \n\n    this.stats = new Stats(); \n\n    this.clock = new THREE.Clock(); \n  }\n\n  componentDidMount() {\n    // Set renderer properties\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.renderer.setPixelRatio(window.devicePixelRatio);\n    this.renderer.outputEncoding = THREE.sRGBEncoding; \n\n    // Mount the canvas at the current div. \n    this.ref.current.appendChild(this.renderer.domElement); \n    this.ref.current.appendChild(this.stats.dom);\n\n    // -------- Lighting ----------------\n    var ambientLight = new THREE.AmbientLight(0xD7D3D3);\n    ambientLight.intensity = 1.5;\n    var directionalLight = new THREE.DirectionalLight(0xffffff);\n    directionalLight.intensity = 3.0;\n    directionalLight.position.set(0, 50, 50).normalize();\n    this.scene.add(ambientLight);\n    this.scene.add(directionalLight);\t\n\n    // ---------- Geometry -----------------\n    let minHeight = -100; \n    let maxHeight = 100; \n    let numAgents = 12; \n    let phase = [0, 0, 3, 3, 5, 5, 7, 7, 9, 9, 11, 11]; \n    let inc = (Math.abs(minHeight) + maxHeight)/numAgents; \n    let startPos = minHeight; \n\n    for (let i = 0; i < numAgents; i++) {\n        let l = new Liarbird(this.scene, i, startPos, phase[i]); \n        this.liarbirds.push(l); \n        startPos += inc; \n    }\n\n    // ---------- Camera -------------------\n    this.controls.enablePan = false;\n    // controls.autoRotate = true; \n    // controls.autoRotateSpeed = 0.1;\n    this.controls.enabled = false; \n    this.controls.enableKeys = false;\n\n    // ---------- Flock Pattern ---------------\n    let o = new THREE.Vector3(0, 0, 0); // Flock around the origin. \n    let moveFactor = THREE.Math.degToRad(0.1); \n    // (Origin Vector, RadiusX, RadiusZ, Amplitude, isClockwise, MoveFactor)\n    let patternObj = ellipseConstructor(o, 60, 0, 80, true, moveFactor);\n    this.flockPattern = new EllipsePattern(patternObj);   \n\n    this.scene.add(new THREE.AxesHelper(30));\n    this.initThreeRender(); \n    this.scheduleStates(); \n  }\n\n  update() {\n    // Flocking updates. \n    if (this.curWorldState === WORLD_STATE.FLOCK) {\n      this.flockPattern.update(); \n      let flockTarget = this.flockPattern.getTargetPos(); \n      // Update octree manager for flocking. \n      this.octreeManager.update(flockTarget, this.liarbirds); \n    }\n\n    var delta = this.clock.getDelta(); \n    let nAgents = []; \n    if (this.liarbirds.length > 0) {\n      this.liarbirds.forEach(l => {\n        // When in flock state, set same target for everybody.\n        if (this.curWorldState === WORLD_STATE.FLOCK) {\n          let flockTarget = this.flockPattern.getTargetPos(); \n          l.setTarget(flockTarget); \n          nAgents = this.octreeManager.getNeighbours(l.position); \n        } else {\n          // We are not flocking right now, so ROSE pattern it is. \n          l.updateRosePattern(); \n        }\n\n        // Send neighboring agents for flocking. \n        l.update(delta, nAgents); \n      }); \n    }\n  }\n\n  render() {\n    return (\n        <div style={styles.container} ref={this.ref} />\n    );\n  }\n\n  initThreeRender() {\n    // Render loop. \n    this.stats.begin();\n    this.update(); \n    this.controls.update();\n    this.renderer.render(this.scene, this.camera);\n    this.stats.end();\n\n    // Register this function as a callback to every repaint from the browser.\n    requestAnimationFrame(this.initThreeRender.bind(this)); \n  }\n\n  updateRendererHeight(h) {\n    let newWidth = window.innerWidth + 500; \n    console.log(newWidth);\n    let newHeight = h; \n    this.renderer.setSize(newWidth, newHeight, true);\n    this.camera.aspect = newWidth/newHeight;\n    this.renderer.setViewport(-500, 0, window.innerWidth+500, h+500);\n    this.camera.updateProjectionMatrix();\n  }\n\n  scheduleStates() {\n    setInterval(() => {\n      if (this.curWorldState === WORLD_STATE.FLOCK) {\n        this.curWorldState = WORLD_STATE.PATTERN; \n      } else {\n        this.curWorldState = WORLD_STATE.FLOCK; \n      }\n    }, 20000); \n  }\n}\n\nexport default Radium(World);","import React from 'react'\nimport Radium from 'radium'\n// import { padding } from './CommonStyles';\nimport World from './World.js'\n\n// const styles = {\n//   content: {\n//     position: 'absolute',\n//     top: '0%',\n//     zIndex: '1',\n//     display: 'flex',\n//     flexDirection: 'column',\n//     alignItems: 'center',\n//     marginLeft: padding.big, \n//     marginRight: padding.big,\n//     overflowX: 'hidden',\n//     overflowY: 'auto',\n\n//     '@media (min-width: 768px)': {  \n//       marginLeft: padding.veryHuge,\n//       marginRight: padding.veryHuge\n//     },\n\n//     '@media (min-width: 600px) and (orientation: landscape)': {  \n//       marginLeft: padding.massive,\n//       marginRight: padding.massive\n//     },\n\n//     '@media (min-width: 1024px)': {  \n//       marginLeft: padding.veryInsane,\n//       marginRight: padding.veryInsane\n//     }\n//   }\n// }\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state={\n    };\n\n    this.totalRef = React.createRef(); \n    this.worldRef = React.createRef(); \n  }\n\n  render() {\n    return (\n      <div>\n          <World ref={this.worldRef} />\n      </div>\n    );\n  }\n\n  componentDidMount() {\n    setTimeout(() => {\n      // let totalHeight = this.totalRef.current.scrollHeight; \n      // let totalHeight = 600; \n      // this.worldRef.current.updateRendererHeight(totalHeight);\n      // console.log(totalHeight);\n    }, 300); \n  }\n\n  componentDidUpdate() {\n    console.log(this.totalRef.current.scrollHeight);\n  }\n}\n\nexport default Radium(App);","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport './font/stylesheet.css';\nimport App from './components/App';\nimport {StyleRoot} from 'radium'\n\n// Use StyleRoot to enable keyframes and media queries for Javascript type\n// styles with Radium in components. \n// Single render function for the entire application. \nReactDOM.render(<StyleRoot><App /></StyleRoot>, document.getElementById('root'));"],"sourceRoot":""}