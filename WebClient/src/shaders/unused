
// void updateBehavior(vec3 updatedTargetPos) {   
//     // Alignment, cohesion, seperation. 
//     vec3 neighborPos, neighborVel; 
//     for (float y = 0.0; y < height; y++) {
//         for (float x = 0.0; x < width; x++) {
//             vec2 ref = vec2(x + 0.5, y + 0.5) / resolution.xy; 
//             vec3 neighborPos = texture2D(texturePosition, ref).xyz;


//         }
//     }

//     // Seek agent target. 
//     seek(updatedTargetPos); 
// }






            // vec3 diffVec = selfPosition - neighborPos; 
            // float l = length(diffVec); 

            // // Am I comparing with myself? Then pass. 
            // if (l < 0.001) {
            //    continue; 
            // } else {
            //     seperate(diffVec);
            //     cohere(diffVec);
            //     align(ref, diffVec);
            // }




    // this make tends to fly around than down or up
    // if (velocity.y > 0.) velocity.y *= (1. - 0.2 * delta);

    // float dist, distSquared; 
    // vec3 dir; // direction

    // float f;
    // float percent;

    // vec3 velocity = selfVelocity;

    // // PREDATOR is basically our target point only right now. 
    // // THIS COULD BE MOUSE COORDINATES THAT COULD disturb the flock. 
    // // Originally that's what it was but I've disabled it for now. 
    // dir = targetPosition - selfPosition;
    // // dir.z = 0.;
    // // dir.z *= 0.6;
    // dist = length(dir);
    // distSquared = dist * dist;

    // float preyRadius = 15.0;
    // float preyRadiusSq = preyRadius * preyRadius;

    // // move birds away from predator
    // if (dist < preyRadius ) {
    //     f = (distSquared / preyRadiusSq - 1.0) * delta * 75.;
    //     velocity += normalize(dir) * f;
    //     // limit += 5.0;
    // }

    // // Attract flocks to the center
    // // Could this be our target??
    // dir = selfPosition - targetPosition;
    // dist = length(dir);
    
    // dir.y *= 2.5;
    // velocity -= normalize(dir) * delta * 50.;

    // Compare the position and velocity of current bird with every
// other bird in the system. This gives shader a O(n2) complexity. 
// It's not the best. Currently we use octree in Javascript side but
// this is giving a really good performance, since this happens in parallel
// across all the birds. Else, it would be O(n3), which would be worse. 
// vec3 calcFlockVelocity(vec3 selfPosition, vec3 selfVelocity) {
//     return vec3(0.0, 0.0, 0.0);
//     // // Helper values. 
//     // zoneRadius = separationDistance + alignmentDistance + cohesionDistance;
//     // separationThresh = separationDistance / zoneRadius;
//     // alignmentThresh = (separationDistance + alignmentDistance) / zoneRadius;
//     // zoneRadiusSquared = zoneRadius * zoneRadius;

//     // vec3 birdPosition, birdVelocity, newVelocity;
//     // float f; 
//     // for (float y = 0.0; y < height; y++ ) {
//     //     for (float x = 0.0; x < width; x++ ) {
//     //         vec2 ref = vec2(x + 0.5, y + 0.5) / resolution.xy;
//     //         birdPosition = texture2D(texturePosition, ref).xyz;

//     //         vec3 dir = birdPosition - selfPosition;
//     //         float dist = length(dir);
//     //         if (dist < 0.0001) { 
//     //             continue;
//     //         }

//     //         float distSquared = dist * dist;
//     //         if (distSquared > zoneRadiusSquared) {
//     //             continue;
//     //         }
//     //         float percent = distSquared / zoneRadiusSquared;

//     //         if (percent < separationThresh) { // low
//     //             // Separation - Move apart for comfort
//     //             f = (separationThresh / percent - 1.0) * delta;
//     //             newVelocity -= normalize(dir) * f;
//     //         } else if (percent < alignmentThresh) { // high
//     //             // Alignment - fly the same direction
//     //             float threshDelta = alignmentThresh - separationThresh;
//     //             float adjustedPercent = (percent - separationThresh) / threshDelta;
//     //             birdVelocity = texture2D(textureVelocity, ref).xyz;
//     //             f = ( 0.5 - cos(adjustedPercent * PI_2) * 0.5 + 0.5 ) * delta;
//     //             newVelocity += normalize(birdVelocity) * f;
//     //         } else {
//     //             // Attraction / Cohesion - move closer
//     //             float threshDelta = 1.0 - alignmentThresh;
//     //             float adjustedPercent;
//     //             if (threshDelta == 0.) {
//     //                 adjustedPercent = 1.;
//     //             }
//     //             else {
//     //                 adjustedPercent = (percent - alignmentThresh) / threshDelta;
//     //             }
//     //             f = (0.5 - (cos( adjustedPercent * PI_2) * (-0.5) + 0.5)) * delta;
//     //             newVelocity += normalize(dir) * f;
//     //         }
//     //     }
//     // }

//     // return newVelocity; 
// }


/*
* HELPER VARIABLES
*/
// float zoneRadius = 40.0;
// float zoneRadiusSquared = 1600.0;
// float separationThresh = 0.45;
// float alignmentThresh = 0.65; 


// void seperate(vec3 diffVec) {
//     vec3 vDesired = diffVec; 
//     vDesired = normalize(vDesired) * uSeperationForce;
//     // Update acceleration.
//     acceleration = acceleration + vDesired; 
// }

// void cohere(vec3 diffVec) {
//     vec3 vDesired = diffVec; 
//     vDesired *= (-1.0); 
//     vDesired = normalize(vDesired) * uCohesionForce; 
//     acceleration = acceleration + vDesired; 
// }

// void align(vec2 ref, vec3 diffVec) {    
//     vec3 neighborVel = texture2D(textureVelocity, ref).xyz;
//     vec3 vDesired = neighborVel; 
//     float l = length(diffVec);
//     vDesired = vDesired / l; 
//     vDesired = normalize(vDesired) * uAlignmentForce; 
//     acceleration = acceleration + vDesired; 
// }
